# Solution Stack
* **Database: MongoDB**
  1. **Horizontal scale support**
    *More cost-effective compared to traditional SQL databases when needing to scale to serve large volumes of data and traffic.*
  1. **Mobile app query and caching support** 
    *Performant mobile app database queries and caching are enabled by Minimongo.*
  1. **GeoSearch support**
    *This API makes it easier to query geolocation data on either server side or client side. For example, for future development, job invites are sent to tradies who only work in certain suburbs/distance.*

* **Server: MeteorJS**
  *Meteor has a built-in MongoDB support and uses a publish-subscribe pattern to automatically propagate data changes to clients(similar to socket.io). If users accept a job invite and they have a good connection to the server, they can see the job moved from the invited tab screen to the accepted tab screen immediately. (Optimistic UI/Offline requests will be discussed separately below)*

* **Client: React Native**
  *Write once and run on both iOS and Android.*

The good thing is the whole tech stack(database, server and mobile apps) is written in one language: JavaScript, which could make the tech stack easier to manage with given limited resources.

# Run the app
## 1. Setup 
Please have the following dependencies installed in your environment:
* Meteor - v1.12.0.+. Check https://www.meteor.com/install for install information.
* Node - v14.15.+. Check https://nodejs.org/en/download/ for install information.
* React Native - v0.63.4.+. Check https://reactnative.dev/docs/environment-setup for install information.
## 2. Start the map server
Open a new terminal window, change the directory to *./lead_server*:
  1. Install the dependencies.
    `meteor npm install`
  1. Start the server.
    `meteor`
Note: The meteor server start point is ./lead_server/server/main.js. The imports directory is used to support Js imports syntax which is not generally supported in other directories. 
## 3. Start the lead managment react native app
Open a new terminal window, change the directory to *./lead_rn*:
  1. Install the dependencies, run:
    `npm install`
  1. Install Pods. under *./ios*, run:
    `pod install`
  1. Start Metro, under *./lead_rn*, run:
    `npm start`
  1. Open a new terminal window under the same directory, 
    `npm run ios`

# Design Guide
## 1. Assumptions
  1. Test data from *./lead_server/imports/startup/server/dataset* which simulates real-world data are dumped into the server database when the server gets started.
  1. Authentication flow is not implemented in either the server or the mobile app. A hard-coded test user(Devin Chen, as saved in `~/dataset/user.json`) has logged in both to the mobile app and the server.
## 2. Data Management Pattern
  Event Sourcing and CQRS patterns are implemented to manage data flow in this project.
  There are three collections created in the server database: `JobEvents`, `Categories` and `Suburbs`. 

  The command model is built and saved in `JobEvents` with the following structure:
  * jid
  * type
  * data
  * auth
  * timestamp

  The query model is built as a view and re-generated by per request or data changes. See *./lead_server/imports/startup/server/publications/jobEventsInvited, JobEventsAccepted* for more details.
  Once the two publications see changes in the `JobEvents` cursor, they run the aggregation function again to publish the updated data to clients. Note: a more specific selector needs to be passed in to `JobEvents` to avoid monitoring on the whole collection to optimise performance.
  Invited view and Accepted view are published and saved to client side minimongo collections as: `JobEventsInvited` and `JobEventsInvited` with the following structure:
  * jid
  * jobDetails
  * timestamp
  A history array is not built to save the history of user interactions to a certain job as a user can only accept or decline a job in the system. Only the final status of a job for a user is returned in jobDetails.

  There are four collections exist on client side: `Categories`, `Suburbs`, `JobEventsInvited` and `JobEventsAccepted`. Foreign key queries to get categories and suburbs data happen on client side.

  Critical Thinking: A new job can be distributed to multiple tradies. A tradie can accept or decline a job. Once a job is accepted by a tradie, the job becomes unavailable/invisible immediately to the other tradies. If a job is declined by a tradie, the job only disappears in their invited job list. This implementaion is done in the `.~/publications/jobEventsAccept` aggregation function.
## 3. Client Server Data Communications
  Client server data communications are based on Meteor's methods(*./lead_server/imports/startup/server/methods*) and the built-in publication/subscription pattern.
  Realtime data are automatically synced to subscribers.
  
  There are only two mehtods: `acceptJob` and `declineJob` allowed to call from clients.

  There are four publications set on the server to propagate data changes to clients. Please refer to *./lead_server/imports/startup/server/publications* for more information. Clients subscribe to the four publications to get the lastest data for the four collections respectively.

# Testing
Due to the time constraint, there are minimal test cases done on the react native app for demo purposes.
Run the test scripts under *./lead_rn*: `npm test`
## Unit Tests
1. Requests. *./lead_rn/src/methods/jobEventsRequests.test.js*
1. Functions: *./lead_rn/src/utils/helpers/jobEventsViews.test.js*
## Component Tests
*./lead_rn/src/components/InvitedLeadCard/AcceptButton.test.js*
1. Testing Rendered Output. 
1. Testing User Interactions. 
## Integration Tests
Cavy. https://github.com/pixielabs/cavy
## End-to-End Test
Detox. https://github.com/wix/detox/

# TODOS
Due to the time constraint, the following features are treated as improvements for this project:
  1. Error Boundary. Wrap components that have a higher risk of crashing into a custom error boundary component to handle component crashing gracefully.
  1. Authentications flow. Authentications flow is not yet implemented. A logged-in user is mocked in both the server and the react native app.
  1. A Github submodule/npm package could be set up to share utilities(the utils folder) that are used in both the server and the app. Now they are declared separately.
  1. Client side caching can be done with some storage systems, e.g., AsyncStorage.
  1. Testing on the server.